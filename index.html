<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>ExoVis</title>
    <style>
      body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <!-- following script enables LiveReload -->
  <script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')
  </script>
  <body>
    <script src="js/lib/three.js"></script>
    <script src="js/lib/TrackballControls.js"></script>
    <script src="js/lib/jquery.js"></script>
    <script>
    // Create a WebGLRenderer
    var renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerWidth);

    document.body.appendChild(renderer.domElement);

    renderer.setClearColor(0x000000, 1.0);
    renderer.clear();

    // SCENE
    var scene = new THREE.Scene();
    var sceneCube = new THREE.Scene(); //this is a scene rendered specifically for the skybox

    // CAMERA
    // args sig -> new THREE.PerspectiveCamera( FOV, viewAspectRatio, zNear, zFar );
    var camera = new THREE.PerspectiveCamera(45, document.body.clientWidth / document.body.clientHeight, 1, 10000);
    camera.position.z = 1500;
    // camera dedicated to skybox
    var cameraCube = new THREE.PerspectiveCamera(45, document.body.clientWidth / document.body.clientHeight, 1, 10000);

    //add skybox
    var urlPrefix = "textures/skybox/";
    var urls = [
      urlPrefix + "pos-x.png", urlPrefix + "neg-x.png",
      urlPrefix + "pos-y.png", urlPrefix + "neg-y.png",
      urlPrefix + "pos-z.png", urlPrefix + "neg-z.png"
    ];

    var cubemap = THREE.ImageUtils.loadTextureCube(urls); // load textures
    cubemap.format = THREE.RGBFormat;

    var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
    shader.uniforms['tCube'].value = cubemap; // apply textures to shader

// create shader material
    var skyBoxMaterial = new THREE.ShaderMaterial( {
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: shader.uniforms,
      depthWrite: false,
      side: THREE.BackSide
    }); 

// create skybox mesh
    var skybox = new THREE.Mesh(
      new THREE.CubeGeometry(10000, 10000, 10000),
      skyBoxMaterial
    );

    scene.add(skybox);

    //controls for camera angle
    controls = new THREE.TrackballControls(camera);

    controls.rotateSpeed = 1.0;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 0.8;

    controls.noZoom = false;
    controls.noPan = false;

    controls.staticMoving = true;
    controls.dynamicDampingFactor = 0.3;

    //adds functions in conjuction with mouse click:
    // A = rotate, S = zoom, D = pan
    controls.keys = [65, 83, 68];

    controls.addEventListener( 'change', render );

    //add lighting sources
    var ambient = new THREE.AmbientLight(0xffffff);
    scene.add(ambient);

    var starlight = new THREE.PointLight(0xffffff, 10, 1000);

    var star = new THREE.Mesh(new THREE.SphereGeometry(50, 30, 30),
      new THREE.MeshPhongMaterial({ambient: 0xFFCC11}));
    scene.add(star);
    star.add(starlight);

    var planet1 = new THREE.Mesh(new THREE.SphereGeometry(15, 20, 16),
      new THREE.MeshPhongMaterial({color: 0xAADD00, ambient: 0x1a1a1a}));
    planet1.position.set(50,0,0);
    scene.add(planet1);

    var planet2 = new THREE.Mesh(new THREE.SphereGeometry(25, 20, 16),
      new THREE.MeshPhongMaterial({color: 0xCD5555, ambient: 0x1a1a1a}));
    planet2.position.set(-100,0,0);
    scene.add(planet2);

    var time = 0,
      speed = 1;
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      render();

      time = time + speed;
      var p1_angle = time * 0.01,
      p2_angle = time * 0.004;
      planet1.position.set(200* Math.cos(p1_angle), 200*Math.sin(p1_angle), 0);
      planet2.position.set(350* Math.cos(p2_angle), 350*Math.sin(p2_angle), 0);
    }

    animate();

    function render() {

      cameraCube.rotation.copy(camera.rotation); // ties skybox camera to regular camera
      renderer.render(sceneCube, cameraCube)
      renderer.render(scene, camera );
    }

    </script>
  </body>
</html>